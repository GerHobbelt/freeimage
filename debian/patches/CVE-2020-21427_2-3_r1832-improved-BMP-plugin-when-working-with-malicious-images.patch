Fix 2/3 for CVE-2020-21427
Origin: upstream, r1832: https://sourceforge.net/p/freeimage/svn/1832
Index: freeimage-3.17.0+ds1/Source/FreeImage/PluginBMP.cpp
===================================================================
--- freeimage-3.17.0+ds1.orig/Source/FreeImage/PluginBMP.cpp
+++ freeimage-3.17.0+ds1/Source/FreeImage/PluginBMP.cpp
@@ -180,6 +180,7 @@ LoadPixelData(FreeImageIO *io, fi_handle
 		}
 	}
 #endif
+
 #if FREEIMAGE_COLORORDER == FREEIMAGE_COLORORDER_RGB
 	if (bit_count == 24 || bit_count == 32) {
 		for(unsigned y = 0; y < FreeImage_GetHeight(dib); y++) {
@@ -201,7 +202,7 @@ Load image pixels for 4-bit RLE compress
 @param handle FreeImage IO handle
 @param width Image width
 @param height Image height
-@param dib Image to be loaded 
+@param dib 4-bit image to be loaded 
 @return Returns TRUE if successful, returns FALSE otherwise
 */
 static BOOL 
@@ -216,7 +217,9 @@ LoadPixelDataRLE4(FreeImageIO *io, fi_ha
 		height = abs(height);
 
 		pixels = (BYTE*)malloc(width * height * sizeof(BYTE));
-		if(!pixels) throw(1);
+		if (!pixels) {
+			throw(1);
+		}
 		memset(pixels, 0, width * height * sizeof(BYTE));
 
 		BYTE *q = pixels;
@@ -236,7 +239,7 @@ LoadPixelDataRLE4(FreeImageIO *io, fi_ha
 					throw(1);
 				}
 				for (int i = 0; i < status_byte; i++)	{
-					*q++=(BYTE)((i & 0x01) ? (second_byte & 0x0f) : ((second_byte >> 4) & 0x0f));
+					*q++ = (BYTE)((i & 0x01) ? (second_byte & 0x0f) : ((second_byte >> 4) & 0x0f));
 				}
 				bits += status_byte;
 			}
@@ -251,7 +254,7 @@ LoadPixelDataRLE4(FreeImageIO *io, fi_ha
 						// End of line
 						bits = 0;
 						scanline++;
-						q = pixels + scanline*width;
+						q = pixels + scanline * width;
 					}
 					break;
 
@@ -263,7 +266,6 @@ LoadPixelDataRLE4(FreeImageIO *io, fi_ha
 					case RLE_DELTA:
 					{
 						// read the delta values
-
 						BYTE delta_x = 0;
 						BYTE delta_y = 0;
 
@@ -275,7 +277,6 @@ LoadPixelDataRLE4(FreeImageIO *io, fi_ha
 						}
 
 						// apply them
-
 						bits += delta_x;
 						scanline += delta_y;
 						q = pixels + scanline*width+bits;
@@ -292,7 +293,7 @@ LoadPixelDataRLE4(FreeImageIO *io, fi_ha
 									throw(1);
 								}
 							}
-							*q++=(BYTE)((i & 0x01) ? (second_byte & 0x0f) : ((second_byte >> 4) & 0x0f));
+							*q++ = (BYTE)((i & 0x01) ? (second_byte & 0x0f) : ((second_byte >> 4) & 0x0f));
 						}
 						bits += status_byte;
 						// Read pad byte
@@ -333,7 +334,9 @@ LoadPixelDataRLE4(FreeImageIO *io, fi_ha
 		return TRUE;
 
 	} catch(int) {
-		if(pixels) free(pixels);
+		if (pixels) {
+			free(pixels);
+		}
 		return FALSE;
 	}
 }
@@ -344,7 +347,7 @@ Load image pixels for 8-bit RLE compress
 @param handle FreeImage IO handle
 @param width Image width
 @param height Image height
-@param dib Image to be loaded 
+@param dib 8-bit image to be loaded 
 @return Returns TRUE if successful, returns FALSE otherwise
 */
 static BOOL 
@@ -353,103 +356,85 @@ LoadPixelDataRLE8(FreeImageIO *io, fi_ha
 	BYTE second_byte = 0;
 	int scanline = 0;
 	int bits = 0;
+	int count = 0;
+	BYTE delta_x = 0;
+	BYTE delta_y = 0;
+
+	height = abs(height);
+	
+	while(scanline < height) {
 
-	for (;;) {
-		if( io->read_proc(&status_byte, sizeof(BYTE), 1, handle) != 1) {
+		if (io->read_proc(&status_byte, sizeof(BYTE), 1, handle) != 1) {
 			return FALSE;
 		}
 
-		switch (status_byte) {
-			case RLE_COMMAND :
-				if(io->read_proc(&status_byte, sizeof(BYTE), 1, handle) != 1) {
-					return FALSE;
-				}
-
-				switch (status_byte) {
-					case RLE_ENDOFLINE :
-						bits = 0;
-						scanline++;
-						break;
-
-					case RLE_ENDOFBITMAP :
-						return TRUE;
-
-					case RLE_DELTA :
-					{
-						// read the delta values
-
-						BYTE delta_x = 0;
-						BYTE delta_y = 0;
-
-						if(io->read_proc(&delta_x, sizeof(BYTE), 1, handle) != 1) {
-							return FALSE;
-						}
-						if(io->read_proc(&delta_y, sizeof(BYTE), 1, handle) != 1) {
-							return FALSE;
-						}
+		if (status_byte == RLE_COMMAND) {
+			if (io->read_proc(&status_byte, sizeof(BYTE), 1, handle) != 1) {
+				return FALSE;
+			}
 
-						// apply them
+			switch (status_byte) {
+				case RLE_ENDOFLINE:
+					bits = 0;
+					scanline++;
+					break;
 
-						bits     += delta_x;
-						scanline += delta_y;
+				case RLE_ENDOFBITMAP:
+					return TRUE;
 
-						break;
+				case RLE_DELTA:
+					// read the delta values
+					delta_x = 0;
+					delta_y = 0;
+					if (io->read_proc(&delta_x, sizeof(BYTE), 1, handle) != 1) {
+						return FALSE;
 					}
+					if (io->read_proc(&delta_y, sizeof(BYTE), 1, handle) != 1) {
+						return FALSE;
+					}
+					// apply them
+					bits += delta_x;
+					scanline += delta_y;
+					break;
 
-					default :
-					{
-						if(scanline >= abs(height)) {
-							return TRUE;
-						}
-
-						int count = MIN((int)status_byte, width - bits);
-
-						BYTE *sline = FreeImage_GetScanLine(dib, scanline);
-
-						if(io->read_proc((void *)(sline + bits), sizeof(BYTE) * count, 1, handle) != 1) {
+				default:
+					// absolute mode
+					count = MIN((int)status_byte, width - bits);
+					if (count < 0) {
+						return FALSE;
+					}
+					BYTE *sline = FreeImage_GetScanLine(dib, scanline);
+					if (io->read_proc((void *)(sline + bits), sizeof(BYTE) * count, 1, handle) != 1) {
+						return FALSE;
+					}
+					// align run length to even number of bytes
+					if ((status_byte & 1) == 1) {
+						if (io->read_proc(&second_byte, sizeof(BYTE), 1, handle) != 1) {
 							return FALSE;
 						}
-						
-						// align run length to even number of bytes 
-
-						if ((status_byte & 1) == 1) {
-							if(io->read_proc(&second_byte, sizeof(BYTE), 1, handle) != 1) {
-								return FALSE;
-							}
-						}
-
-						bits += status_byte;													
-
-						break;	
 					}
-				}
-
-				break;
-
-			default :
-			{
-				if(scanline >= abs(height)) {
-					return TRUE;
-				}
-
-				int count = MIN((int)status_byte, width - bits);
-
-				BYTE *sline = FreeImage_GetScanLine(dib, scanline);
-
-				if(io->read_proc(&second_byte, sizeof(BYTE), 1, handle) != 1) {
-					return FALSE;
-				}
-
-				for (int i = 0; i < count; i++) {
-					*(sline + bits) = second_byte;
-
-					bits++;					
-				}
+					bits += status_byte;				
+					break;
 
-				break;
+			} // switch (status_byte)
+		}
+		else {
+			count = MIN((int)status_byte, width - bits);
+			if (count < 0) {
+				return FALSE;
+			}
+			BYTE *sline = FreeImage_GetScanLine(dib, scanline);
+			if (io->read_proc(&second_byte, sizeof(BYTE), 1, handle) != 1) {
+				return FALSE;
+			}
+			for (int i = 0; i < count; i++) {
+				*(sline + bits) = second_byte;
+				bits++;
 			}
 		}
 	}
+	
+	return FALSE;
 }
 
 // --------------------------------------------------------------------------
@@ -462,10 +447,12 @@ LoadWindowsBMP(FreeImageIO *io, fi_handl
 		BOOL header_only = (flags & FIF_LOAD_NOPIXELS) == FIF_LOAD_NOPIXELS;
 
 		// load the info header
-
 		BITMAPINFOHEADER bih;
+		memset(&bih, 0, sizeof(BITMAPINFOHEADER));
+		if (io->read_proc(&bih, sizeof(BITMAPINFOHEADER), 1, handle) != 1) {
+			throw FI_MSG_ERROR_INVALID_FORMAT;
+		}
 
-		io->read_proc(&bih, sizeof(BITMAPINFOHEADER), 1, handle);
 #ifdef FREEIMAGE_BIGENDIAN
 		SwapInfoHeader(&bih);
 #endif
@@ -513,8 +500,8 @@ LoadWindowsBMP(FreeImageIO *io, fi_handl
 				}
 				
 				// load the palette
-
 				io->read_proc(FreeImage_GetPalette(dib), used_colors * sizeof(RGBQUAD), 1, handle);
+
 #if FREEIMAGE_COLORORDER == FREEIMAGE_COLORORDER_RGB
 				RGBQUAD *pal = FreeImage_GetPalette(dib);
 				for(int i = 0; i < used_colors; i++) {
@@ -543,7 +530,7 @@ LoadWindowsBMP(FreeImageIO *io, fi_handl
 						break;
 
 					case BI_RLE4 :
-						if( LoadPixelDataRLE4(io, handle, width, height, dib) ) {
+						if( (bit_count == 4) && LoadPixelDataRLE4(io, handle, width, height, dib) ) {
 							return dib;
 						} else {
 							throw "Error encountered while decoding RLE4 BMP data";
@@ -551,7 +538,7 @@ LoadWindowsBMP(FreeImageIO *io, fi_handl
 						break;
 
 					case BI_RLE8 :
-						if( LoadPixelDataRLE8(io, handle, width, height, dib) ) {
+						if( (bit_count == 8) && LoadPixelDataRLE8(io, handle, width, height, dib) ) {
 							return dib;
 						} else {
 							throw "Error encountered while decoding RLE8 BMP data";
@@ -601,7 +588,7 @@ LoadWindowsBMP(FreeImageIO *io, fi_handl
 
 				return dib;
 			}
-			break; // 16-bit
+			break; // 16-bit RGB
 
 			case 24 :
 			case 32 :
@@ -678,10 +665,12 @@ LoadOS22XBMP(FreeImageIO *io, fi_handle
 		BOOL header_only = (flags & FIF_LOAD_NOPIXELS) == FIF_LOAD_NOPIXELS;
 
 		// load the info header
-
 		BITMAPINFOHEADER bih;
+		memset(&bih, 0, sizeof(BITMAPINFOHEADER));
+		if (io->read_proc(&bih, sizeof(BITMAPINFOHEADER), 1, handle) != 1) {
+			throw FI_MSG_ERROR_INVALID_FORMAT;
+		}
 
-		io->read_proc(&bih, sizeof(BITMAPINFOHEADER), 1, handle);
 #ifdef FREEIMAGE_BIGENDIAN
 		SwapInfoHeader(&bih);
 #endif
@@ -766,17 +755,19 @@ LoadOS22XBMP(FreeImageIO *io, fi_handle
 						return dib;
 
 					case BI_RLE4 :
-						if( LoadPixelDataRLE4(io, handle, width, height, dib) ) {
+						if ((bit_count == 4) && LoadPixelDataRLE4(io, handle, width, height, dib)) {
 							return dib;
-						} else {
+						}
+						else {
 							throw "Error encountered while decoding RLE4 BMP data";
 						}
 						break;
 
 					case BI_RLE8 :
-						if( LoadPixelDataRLE8(io, handle, width, height, dib) ) {
+						if ((bit_count == 8) && LoadPixelDataRLE8(io, handle, width, height, dib)) {
 							return dib;
-						} else {
+						}
+						else {
 							throw "Error encountered while decoding RLE8 BMP data";
 						}
 						break;
@@ -862,9 +853,9 @@ LoadOS22XBMP(FreeImageIO *io, fi_handle
 			}
 		}
 	} catch(const char *message) {
-		if(dib)
+		if (dib) {
 			FreeImage_Unload(dib);
-
+		}
 		FreeImage_OutputMessageProc(s_format_id, message);
 	}
 
@@ -880,9 +871,13 @@ LoadOS21XBMP(FreeImageIO *io, fi_handle
 	try {
 		BOOL header_only = (flags & FIF_LOAD_NOPIXELS) == FIF_LOAD_NOPIXELS;
 
+		// load the info header
 		BITMAPINFOOS2_1X_HEADER bios2_1x;
+		memset(&bios2_1x, 0, sizeof(BITMAPINFOOS2_1X_HEADER));
+		if (io->read_proc(&bios2_1x, sizeof(BITMAPINFOOS2_1X_HEADER), 1, handle) != 1) {
+			throw FI_MSG_ERROR_INVALID_FORMAT;
+		}
 
-		io->read_proc(&bios2_1x, sizeof(BITMAPINFOOS2_1X_HEADER), 1, handle);
 #ifdef FREEIMAGE_BIGENDIAN
 		SwapOS21XHeader(&bios2_1x);
 #endif
@@ -1004,9 +999,9 @@ LoadOS21XBMP(FreeImageIO *io, fi_handle
 			}
 		}
 	} catch(const char *message) {	
-		if(dib)
+		if (dib) {
 			FreeImage_Unload(dib);
-
+		}
 		FreeImage_OutputMessageProc(s_format_id, message);
 	}
 
@@ -1089,28 +1084,29 @@ Load(FreeImageIO *io, fi_handle handle,
 		BITMAPFILEHEADER bitmapfileheader;
 		DWORD type = 0;
 
-		// we use this offset value to make seemingly absolute seeks relative in the file
-		
+		// we use this offset value to make seemingly absolute seeks relative in the file		
 		long offset_in_file = io->tell_proc(handle);
 
 		// read the fileheader
+		memset(&bitmapfileheader, 0, sizeof(BITMAPFILEHEADER));
+		if (io->read_proc(&bitmapfileheader, sizeof(BITMAPFILEHEADER), 1, handle) != 1) {
+			return NULL;
+		}
 
-		io->read_proc(&bitmapfileheader, sizeof(BITMAPFILEHEADER), 1, handle);
 #ifdef FREEIMAGE_BIGENDIAN
 		SwapFileHeader(&bitmapfileheader);
 #endif
 
 		// check the signature
-
 		if((bitmapfileheader.bfType != 0x4D42) && (bitmapfileheader.bfType != 0x4142)) {
 			FreeImage_OutputMessageProc(s_format_id, FI_MSG_ERROR_MAGIC_NUMBER);
 			return NULL;
 		}
 
 		// read the first byte of the infoheader
-
 		io->read_proc(&type, sizeof(DWORD), 1, handle);
 		io->seek_proc(handle, 0 - (long)sizeof(DWORD), SEEK_CUR);
+
 #ifdef FREEIMAGE_BIGENDIAN
 		SwapLong(&type);
 #endif
@@ -1137,7 +1133,7 @@ Load(FreeImageIO *io, fi_handle handle,
 				break;
 		}
 
-		FreeImage_OutputMessageProc(s_format_id, "unknown bmp subtype with id %d", type);
+		FreeImage_OutputMessageProc(s_format_id, "Unknown bmp subtype with id %d", type);
 	}
 
 	return NULL;
@@ -1401,6 +1397,7 @@ Save(FreeImageIO *io, FIBITMAP *dib, fi_
 			}
 
 			free(buffer);
+
 #ifdef FREEIMAGE_BIGENDIAN
 		} else if (bpp == 16) {
 			int padding = FreeImage_GetPitch(dib) - FreeImage_GetWidth(dib) * sizeof(WORD);
@@ -1421,6 +1418,7 @@ Save(FreeImageIO *io, FIBITMAP *dib, fi_
 				}
 			}
 #endif
+
 #if FREEIMAGE_COLORORDER == FREEIMAGE_COLORORDER_RGB
 		} else if (bpp == 24) {
 			int padding = FreeImage_GetPitch(dib) - FreeImage_GetWidth(dib) * sizeof(FILE_BGR);
