Subject: fix CVE-2019-12213 and CVE-2019-12211
Author: Herve Drolon <drolon@infonie.fr>
Origin: upstream, https://sourceforge.net/p/freeimage/svn/1825/
--- a/Source/FreeImage/PluginTIFF.cpp	2019-12-16 14:05:02.150620798 +0100
+++ b/Source/FreeImage/PluginTIFF.cpp	2019-12-16 14:05:02.146620830 +0100
@@ -122,9 +122,14 @@
 static int s_format_id;
 
 typedef struct {
+    //! FreeImage IO functions
     FreeImageIO *io;
-	fi_handle handle;
-	TIFF *tif;
+    //! FreeImage handle
+    fi_handle handle;
+    //! LibTIFF handle
+    TIFF *tif;
+    //! Count the number of thumbnails already read (used to avoid recursion on loading)
+    unsigned thumbnailCount;
 } fi_TIFFIO;
 
 // ----------------------------------------------------------
@@ -184,10 +189,8 @@
 */
 TIFF *
 TIFFFdOpen(thandle_t handle, const char *name, const char *mode) {
-	TIFF *tif;
-	
 	// Open the file; the callback will set everything up
-	tif = TIFFClientOpen(name, mode, handle,
+	TIFF *tif = TIFFClientOpen(name, mode, handle,
 	    _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc,
 	    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);
 
@@ -452,9 +455,9 @@
 			}
 			
 		}
-		else {
+		else if (bpp <= 32) {
 
-			dib = FreeImage_AllocateHeader(header_only, width, height, MIN(bpp, 32), FI_RGBA_RED_MASK, FI_RGBA_GREEN_MASK, FI_RGBA_BLUE_MASK);
+			dib = FreeImage_AllocateHeader(header_only, width, height, bpp, FI_RGBA_RED_MASK, FI_RGBA_GREEN_MASK, FI_RGBA_BLUE_MASK);
 		}
 
 
@@ -1041,6 +1044,7 @@
 	if(!fio) return nullptr;
 	fio->io = io;
 	fio->handle = handle;
+	fio->thumbnailCount = 0;
 
 	if (read) {
 		fio->tif = TIFFFdOpen((thandle_t)fio, "", "r");
@@ -1096,6 +1100,27 @@
 */
 static BOOL 
 IsValidBitsPerSample(uint16_t photometric, uint16_t bitspersample, uint16_t samplesperpixel) {
+        // get the pixel depth in bits
+        const uint16_t pixel_depth = bitspersample * samplesperpixel;
+
+        // check for a supported pixel depth
+        switch (pixel_depth) {
+            case 1:
+            case 4:
+            case 8:
+            case 16:
+            case 24:
+            case 32:
+            case 48:
+            case 64:
+            case 96:
+            case 128:
+                // OK, go on
+                break;
+            default:
+                // unsupported pixel depth
+                return FALSE;
+        }
 
 	switch(bitspersample) {
 		case 1:
@@ -1136,6 +1161,8 @@
 		default:
 			return FALSE;
 	}
+
+    return FALSE;
 }
 
 static TIFFLoadMethod  
@@ -1226,11 +1253,30 @@
 ReadThumbnail(FreeImageIO *io, fi_handle handle, void *data, TIFF *tiff, FIBITMAP *dib) {
 	FIBITMAP* thumbnail = nullptr;
 
+        fi_TIFFIO *fio = (fi_TIFFIO*)data;
+
+        /*
+        Thumbnail loading can cause recursions because of the way
+        functions TIFFLastDirectory and TIFFSetSubDirectory are working.
+        We use here a hack to count the number of times the ReadThumbnail function was called.
+        We only allow one call, check for this
+        */
+        if (fio->thumbnailCount > 0) {
+            return;
+        }
+        else {
+            // update the thumbnail count (used to avoid recursion)
+            fio->thumbnailCount++;
+        }
+
 	// read exif thumbnail (IFD 1) ...
 
 	uint32_t exif_offset = 0;
 	if(TIFFGetField(tiff, TIFFTAG_EXIFIFD, &exif_offset)) {
 
+        // this code can cause unwanted recursion causing an overflow, because of the way TIFFLastDirectory work
+        // => this is checked using
+
 		if(TIFFLastDirectory(tiff) != 0) {
 			// save current position
 			long tell_pos = io->tell_proc(handle);
@@ -1261,6 +1307,8 @@
 				// save current position
 				long tell_pos = io->tell_proc(handle);
 				uint16_t cur_dir = TIFFCurrentDirectory(tiff);
+
+                                // this code can cause unwanted recursion causing an overflow, because of the way TIFFSetSubDirectory work
 				if(TIFFSetSubDirectory(tiff, subIFD_offsets[0])) {
 					// load the thumbnail
 					int page = -1; 
@@ -2021,7 +2069,7 @@
 				}
 
 				// calculate src line and dst pitch
-				int dst_pitch = FreeImage_GetPitch(dib);
+				unsigned dst_pitch = FreeImage_GetPitch(dib);
 				uint32_t tileRowSize = (uint32_t)TIFFTileRowSize(tif);
 				uint32_t imageRowSize = (uint32_t)TIFFScanlineSize(tif);
 
@@ -2051,7 +2099,7 @@
 						uint8_t *src_bits = tileBuffer;
 						uint8_t *dst_bits = bits + rowSize;
 						for(int k = 0; k < nrows; k++) {
-							memcpy(dst_bits, src_bits, src_line);
+							memcpy(dst_bits, src_bits, MIN(dst_pitch, src_line));
 							src_bits += tileRowSize;
 							dst_bits -= dst_pitch;
 						}
